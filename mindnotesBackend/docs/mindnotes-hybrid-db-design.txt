# ============================================================
# ARCHITECTURE ANALYSIS & HYBRID DATABASE DESIGN
# ============================================================

"""
HYBRID DATABASE ARCHITECTURE DECISION FOR MINDNOTES

After analyzing the data flow and requirements, here's the optimal database strategy:

┌─────────────────────────────────────────────────────────────┐
│                    DATA CLASSIFICATION                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  POSTGRESQL (Relational Data - ACID Required)              │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━   │
│  ✓ User accounts & authentication                           │
│  ✓ User profiles & settings                                 │
│  ✓ Subscription plans & billing                             │
│  ✓ Payment transactions                                     │
│  ✓ User relationships & permissions                         │
│  ✓ Tags (need relational queries)                          │
│  ✓ Mood categories & factors (reference data)              │
│  ✓ Focus programs structure (template data)                │
│  ✓ Prompt categories (reference data)                      │
│                                                              │
│  MONGODB (Document-Oriented - High Write Volume)            │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━   │
│  ✓ Journal entries (text, metadata, nested structures)     │
│  ✓ Journal photos & voice notes (metadata + file refs)     │
│  ✓ Prompt responses (flexible schema)                      │
│  ✓ Mood entries (time-series data, frequent writes)        │
│  ✓ Focus sessions (time-series, real-time tracking)        │
│  ✓ User program progress (dynamic nested data)             │
│  ✓ Daily prompt sets (temporary, regenerated daily)        │
│  ✓ Analytics data (aggregated metrics)                     │
│  ✓ User activity logs (high volume writes)                 │
│  ✓ Export requests (temporary processing data)             │
│                                                              │
└─────────────────────────────────────────────────────────────┘

WHY THIS SPLIT?

POSTGRESQL STRENGTHS (Use for):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. ACID Transactions: Payment processing, subscription changes
2. Complex Joins: User → Subscription → Plan relationships
3. Referential Integrity: Foreign keys, cascade deletes
4. Authentication: Proven, secure user management
5. Aggregations: Financial reporting, user counts

MONGODB STRENGTHS (Use for):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Schema Flexibility: Journal entries vary (text/voice/photo)
2. High Write Volume: Focus timer updates every second
3. Nested Documents: Prompt responses, session metadata
4. Time-Series Data: Mood tracking, analytics over time
5. Horizontal Scaling: Handle millions of journal entries
6. Rich Queries: Text search, date ranges, complex filters
7. Document Versioning: Track entry edits, history

DATA FLOW EXAMPLES:

1. USER CREATES JOURNAL ENTRY
   ┌──────────┐      ┌──────────┐      ┌──────────┐
   │  Client  │─────▶│PostgreSQL│─────▶│ MongoDB  │
   └──────────┘      └──────────┘      └──────────┘
                     Validate user,     Store entry
                     check quota,       content + 
                     get tags           metadata

2. FOCUS TIMER SESSION (Real-time updates)
   ┌──────────┐                        ┌──────────┐
   │  Client  │───────────────────────▶│ MongoDB  │
   └──────────┘   Every tick update    └──────────┘
                  (no PostgreSQL load)

3. SUBSCRIPTION CHECK
   ┌──────────┐      ┌──────────┐
   │  Client  │─────▶│PostgreSQL│
   └──────────┘      └──────────┘
                     Check plan,
                     quota limits

4. ANALYTICS DASHBOARD
   ┌──────────┐      ┌──────────┐      ┌──────────┐
   │  Client  │─────▶│PostgreSQL│      │ MongoDB  │
   └──────────┘      └──────────┘      └──────────┘
                     User info          Aggregate
                                       journal data,
                                       mood trends


"""
POSTGRESQL MODELS (Final List):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
apps/users:
  ✓ User
  ✓ UserProfile (simplified)
  ✓ UserStreak (simplified)
  ✓ UserDevice

apps/journals:
  ✓ Tag
  ✓ EntryTemplate (optional)

apps/moods:
  ✓ MoodCategory
  ✓ CustomMoodCategory
  ✓ MoodFactor

apps/focus:
  ✓ FocusProgram
  ✓ ProgramDay
  ✓ UserFocusProgram (simplified)

apps/prompts:
  ✓ PromptCategory
  ✓ DailyPrompt
  ✓ CustomPrompt

apps/subscriptions:
  ✓ SubscriptionPlan
  ✓ UserSubscription
  ✓ PaymentHistory
  ✓ PromoCode
  ✓ PromoCodeUsage

apps/exports:
  ✓ ExportRequest (metadata only)
  ✓ ScheduledExport

MONGODB DOCUMENTS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ✓ JournalEntryMongo (with embedded photos, voice notes)
  ✓ MoodEntryMongo
  ✓ FocusSessionMongo (with embedded pauses)
  ✓ DailyPromptSetMongo
  ✓ PromptResponseMongo
  ✓ UserAnalyticsMongo (aggregated stats)
  ✓ DailyActivityLogMongo (calendar data)
  ✓ UserProgramProgressMongo (program tracking)
"""

HYBRID QUERY PATTERNS:
━━━━━━━━━━━━━━━━━━━━━━
- Store user_id (UUID) in both databases as linking key
- MongoDB queries filtered by user_id from PostgreSQL session
- Cache frequently accessed PostgreSQL data (user plan, settings)
- Use PostgreSQL for authorization, MongoDB for data operations
"""

# ============================================================
# IMPLEMENTATION: requirements.txt additions
# ============================================================

"""
# Add to requirements.txt:
djongo==1.3.6           # Django MongoDB connector
pymongo==4.6.1          # MongoDB driver
mongoengine==0.27.0     # ODM for MongoDB
"""

# ============================================================
# config/settings/base.py - MongoDB Configuration
# ============================================================

# Add to settings.py:

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': env('POSTGRES_DB', default='mindnotes'),
        'USER': env('POSTGRES_USER', default='postgres'),
        'PASSWORD': env('POSTGRES_PASSWORD', default='postgres'),
        'HOST': env('POSTGRES_HOST', default='localhost'),
        'PORT': env('POSTGRES_PORT', default='5432'),
    }
}

# MongoDB Configuration
MONGODB_DATABASES = {
    'default': {
        'name': env('MONGODB_DB', default='mindnotes'),
        'host': env('MONGODB_HOST', default='localhost'),
        'port': int(env('MONGODB_PORT', default=27017)),
        'username': env('MONGODB_USER', default=''),
        'password': env('MONGODB_PASSWORD', default=''),
        'authentication_source': 'admin',
    }
}

# MongoEngine connection
import mongoengine
mongoengine.connect(
    db=MONGODB_DATABASES['default']['name'],
    host=MONGODB_DATABASES['default']['host'],
    port=MONGODB_DATABASES['default']['port'],
    username=MONGODB_DATABASES['default']['username'],
    password=MONGODB_DATABASES['default']['password'],
    authentication_source=MONGODB_DATABASES['default']['authentication_source'],
)


# ============================================================
# apps/journals/mongo_models.py - MongoDB Models for Journals
# ============================================================

from mongoengine import Document, EmbeddedDocument, fields
from datetime import datetime
import uuid


class PhotoEmbed(EmbeddedDocument):
    """Embedded photo data in journal entry"""
    id = fields.UUIDField(default=uuid.uuid4, primary_key=True)
    image_url = fields.StringField(required=True)
    caption = fields.StringField(max_length=255)
    order = fields.IntField(default=0)
    width = fields.IntField()
    height = fields.IntField()
    file_size = fields.IntField()
    uploaded_at = fields.DateTimeField(default=datetime.utcnow)
    
    meta = {'strict': False}


class VoiceNoteEmbed(EmbeddedDocument):
    """Embedded voice note data"""
    id = fields.UUIDField(default=uuid.uuid4, primary_key=True)
    audio_url = fields.StringField(required=True)
    duration = fields.IntField()  # seconds
    file_size = fields.IntField()  # bytes
    transcription = fields.StringField()
    transcription_language = fields.StringField(default='en')
    is_transcribed = fields.BooleanField(default=False)
    uploaded_at = fields.DateTimeField(default=datetime.utcnow)
    
    meta = {'strict': False}


class PromptResponseEmbed(EmbeddedDocument):
    """Embedded prompt response"""
    prompt_id = fields.IntField()  # Reference to PostgreSQL DailyPrompt
    question = fields.StringField(required=True)
    answer = fields.StringField(required=True)
    word_count = fields.IntField(default=0)
    answered_at = fields.DateTimeField(default=datetime.utcnow)
    
    meta = {'strict': False}


class JournalEntryMongo(Document):
    """
    MongoDB model for journal entries
    Stores the actual entry content and nested data
    """
    # Link to PostgreSQL user
    user_id = fields.UUIDField(required=True, index=True)
    
    # Entry content
    title = fields.StringField(max_length=255)
    content = fields.StringField()
    entry_type = fields.StringField(
        choices=['text', 'voice', 'photo', 'mixed'],
        default='text'
    )
    
    # Metadata
    entry_date = fields.DateTimeField(required=True, index=True)
    privacy = fields.StringField(choices=['private', 'public'], default='private')
    is_favorite = fields.BooleanField(default=False, index=True)
    is_archived = fields.BooleanField(default=False, index=True)
    
    # Tags - Store IDs from PostgreSQL
    tag_ids = fields.ListField(fields.IntField())
    
    # Location
    location_name = fields.StringField()
    latitude = fields.DecimalField(precision=2)
    longitude = fields.DecimalField(precision=2)
    
    # Weather
    weather = fields.StringField()
    temperature = fields.FloatField()
    
    # Statistics
    word_count = fields.IntField(default=0)
    character_count = fields.IntField(default=0)
    reading_time_minutes = fields.IntField(default=0)
    
    # Embedded documents
    photos = fields.ListField(fields.EmbeddedDocumentField(PhotoEmbed))
    voice_notes = fields.ListField(fields.EmbeddedDocumentField(VoiceNoteEmbed))
    prompt_responses = fields.ListField(fields.EmbeddedDocumentField(PromptResponseEmbed))
    
    # Version control
    version = fields.IntField(default=1)
    edit_history = fields.ListField(fields.DictField())
    
    # Timestamps
    created_at = fields.DateTimeField(default=datetime.utcnow, index=True)
    updated_at = fields.DateTimeField(default=datetime.utcnow)
    
    meta = {
        'collection': 'journal_entries',
        'indexes': [
            'user_id',
            'entry_date',
            'is_favorite',
            ('user_id', '-entry_date'),  # Compound index
            {
                'fields': ['$content', '$title'],  # Text search
                'default_language': 'english',
                'weights': {'content': 10, 'title': 5}
            }
        ],
        'ordering': ['-entry_date'],
        'strict': False,  # Allow dynamic fields
    }
    
    def save(self, *args, **kwargs):
        # Auto-update word count and timestamps
        if self.content:
            self.word_count = len(self.content.split())
            self.character_count = len(self.content)
            self.reading_time_minutes = max(1, self.word_count // 200)
        
        self.updated_at = datetime.utcnow()
        return super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.user_id} - {self.entry_date.date()}"


# ============================================================
# apps/moods/mongo_models.py - MongoDB Models for Moods
# ============================================================

class MoodEntryMongo(Document):
    """
    MongoDB model for mood entries (time-series data)
    High write volume, flexible schema for factors
    """
    user_id = fields.UUIDField(required=True, index=True)
    journal_entry_id = fields.UUIDField()  # Link to journal if exists
    
    # Mood data - Store category_id from PostgreSQL
    category_id = fields.IntField()
    custom_category_id = fields.IntField()
    category_name = fields.StringField()  # Denormalized for fast queries
    emoji = fields.StringField()
    
    # Intensity
    intensity = fields.IntField(min_value=1, max_value=10, required=True)
    
    # Context
    note = fields.StringField()
    
    # Factors - flexible structure
    factors = fields.ListField(fields.DictField())  # [{id: 1, name: "Sleep", value: "good"}]
    
    # Time tracking
    recorded_at = fields.DateTimeField(required=True, index=True)
    created_at = fields.DateTimeField(default=datetime.utcnow)
    
    # Additional context (flexible)
    context = fields.DictField()  # Store any additional metadata
    
    meta = {
        'collection': 'mood_entries',
        'indexes': [
            'user_id',
            'recorded_at',
            ('user_id', '-recorded_at'),
            'category_id',
        ],
        'ordering': ['-recorded_at'],
        'strict': False,
    }


# ============================================================
# apps/focus/mongo_models.py - MongoDB Models for Focus Sessions
# ============================================================

class FocusSessionMongo(Document):
    """
    MongoDB model for focus sessions
    Real-time updates, time-series data
    """
    user_id = fields.UUIDField(required=True, index=True)
    
    # Session details
    session_type = fields.StringField(
        choices=['pomodoro', 'custom', 'program'],
        default='custom'
    )
    status = fields.StringField(
        choices=['active', 'completed', 'paused', 'canceled'],
        default='active'
    )
    
    # Durations (in seconds for precision)
    planned_duration_seconds = fields.IntField(required=True)
    actual_duration_seconds = fields.IntField(default=0)
    
    # Task
    task_description = fields.StringField()
    
    # Program association (PostgreSQL IDs)
    program_id = fields.IntField()
    program_day_id = fields.IntField()
    
    # Real-time tracking
    started_at = fields.DateTimeField(required=True, index=True)
    ended_at = fields.DateTimeField()
    last_tick_at = fields.DateTimeField()  # For real-time updates
    
    # Pauses (embedded documents for efficiency)
    pauses = fields.ListField(fields.DictField())  # [{started: datetime, ended: datetime, duration: int}]
    total_pause_duration_seconds = fields.IntField(default=0)
    
    # Feedback
    productivity_rating = fields.IntField(min_value=1, max_value=5)
    notes = fields.StringField()
    
    # Tags for categorization
    tags = fields.ListField(fields.StringField())
    
    # Milestones (for gamification)
    milestones = fields.ListField(fields.DictField())
    
    meta = {
        'collection': 'focus_sessions',
        'indexes': [
            'user_id',
            'started_at',
            'status',
            ('user_id', '-started_at'),
            ('user_id', 'status'),
        ],
        'ordering': ['-started_at'],
    }
    
    def add_pause(self):
        """Add a pause to the session"""
        pause = {
            'started_at': datetime.utcnow(),
            'ended_at': None,
            'duration_seconds': 0
        }
        self.pauses.append(pause)
        self.save()
    
    def resume_pause(self):
        """Resume from latest pause"""
        if self.pauses and self.pauses[-1]['ended_at'] is None:
            pause = self.pauses[-1]
            pause['ended_at'] = datetime.utcnow()
            pause['duration_seconds'] = (pause['ended_at'] - pause['started_at']).seconds
            self.total_pause_duration_seconds += pause['duration_seconds']
            self.save()


# ============================================================
# apps/prompts/mongo_models.py - MongoDB Models for Prompt Sets
# ============================================================

class DailyPromptSetMongo(Document):
    """
    MongoDB model for daily prompt sets
    Regenerated daily, temporary data
    """
    user_id = fields.UUIDField(required=True, index=True)
    date = fields.DateField(required=True, index=True)
    
    # Prompts - Store from PostgreSQL with details
    prompts = fields.ListField(fields.DictField())  # [{id: 1, question: "...", category: "..."}]
    
    # Completion tracking
    completed_prompt_ids = fields.ListField(fields.IntField())
    completed_count = fields.IntField(default=0)
    is_fully_completed = fields.BooleanField(default=False)
    
    # Timestamps
    generated_at = fields.DateTimeField(default=datetime.utcnow)
    last_interaction_at = fields.DateTimeField()
    
    meta = {
        'collection': 'daily_prompt_sets',
        'indexes': [
            'user_id',
            'date',
            ('user_id', 'date'),
        ],
    }


class PromptResponseMongo(Document):
    """User responses to prompts - flexible schema"""
    user_id = fields.UUIDField(required=True, index=True)
    prompt_id = fields.IntField(required=True)  # Reference to PostgreSQL
    daily_set_date = fields.DateField()
    
    # Response
    response = fields.StringField(required=True)
    word_count = fields.IntField(default=0)
    time_spent_seconds = fields.IntField(default=0)
    
    # Context
    mood_at_response = fields.IntField()
    location = fields.DictField()
    
    # Timestamps
    responded_at = fields.DateTimeField(default=datetime.utcnow, index=True)
    
    meta = {
        'collection': 'prompt_responses',
        'indexes': [
            'user_id',
            'prompt_id',
            'responded_at',
            ('user_id', '-responded_at'),
        ],
        'ordering': ['-responded_at'],
    }


# ============================================================
# apps/analytics/mongo_models.py - MongoDB Models for Analytics
# ============================================================

class UserAnalyticsMongo(Document):
    """
    Pre-aggregated analytics data for fast dashboard loading
    Updated periodically via Celery tasks
    """
    user_id = fields.UUIDField(required=True, unique=True, index=True)
    
    # Journal statistics
    total_entries = fields.IntField(default=0)
    total_words = fields.IntField(default=0)
    total_photos = fields.IntField(default=0)
    total_voice_notes = fields.IntField(default=0)
    
    # Streaks
    current_streak = fields.IntField(default=0)
    longest_streak = fields.IntField(default=0)
    
    # Time-based stats
    entries_this_week = fields.IntField(default=0)
    entries_this_month = fields.IntField(default=0)
    entries_this_year = fields.IntField(default=0)
    
    # Mood analytics
    average_mood_intensity = fields.FloatField(default=0)
    mood_distribution = fields.DictField()  # {mood_name: count}
    most_common_mood = fields.StringField()
    
    # Focus analytics
    total_focus_minutes = fields.IntField(default=0)
    total_focus_sessions = fields.IntField(default=0)
    average_session_duration = fields.IntField(default=0)
    
    # Trends
    mood_trend = fields.StringField(choices=['improving', 'stable', 'declining'])
    productivity_trend = fields.StringField(choices=['improving', 'stable', 'declining'])
    
    # Last calculated
    last_calculated_at = fields.DateTimeField(default=datetime.utcnow)
    
    meta = {
        'collection': 'user_analytics',
        'indexes': ['user_id'],
    }


class DailyActivityLogMongo(Document):
    """
    Daily activity aggregation for calendar view
    """
    user_id = fields.UUIDField(required=True, index=True)
    date = fields.DateField(required=True, index=True)
    
    # Activity counts
    journal_entries_count = fields.IntField(default=0)
    mood_entries_count = fields.IntField(default=0)
    focus_sessions_count = fields.IntField(default=0)
    prompt_responses_count = fields.IntField(default=0)
    
    # Aggregated data
    total_words_written = fields.IntField(default=0)
    total_focus_minutes = fields.IntField(default=0)
    average_mood_intensity = fields.FloatField()
    
    # Flags
    has_journal_entry = fields.BooleanField(default=False)
    has_mood_entry = fields.BooleanField(default=False)
    has_focus_session = fields.BooleanField(default=False)
    
    meta = {
        'collection': 'daily_activity_logs',
        'indexes': [
            'user_id',
            'date',
            ('user_id', 'date'),
        ],
    }


# ============================================================
# Hybrid Service Layer Example
# ============================================================

class JournalService:
    """
    Service layer to handle hybrid database operations
    """
    
    @staticmethod
    def create_journal_entry(user, data):
        """
        Create journal entry in MongoDB with PostgreSQL references
        """
        from apps.journals.models import Tag  # PostgreSQL model
        
        # Get tags from PostgreSQL
        tag_ids = data.get('tag_ids', [])
        tags = Tag.objects.filter(id__in=tag_ids, user=user)
        
        # Create MongoDB document
        entry = JournalEntryMongo(
            user_id=user.id,
            title=data.get('title', ''),
            content=data.get('content', ''),
            entry_type=data.get('entry_type', 'text'),
            entry_date=data.get('entry_date'),
            tag_ids=list(tags.values_list('id', flat=True)),
            privacy=data.get('privacy', 'private'),
        )
        entry.save()
        
        # Update PostgreSQL user stats
        profile = user.profile
        profile.total_entries += 1
        profile.save()
        
        return entry
    
    @staticmethod
    def get_user_entries(user, filters=None):
        """
        Get journal entries with filters
        """
        query = {'user_id': user.id}
        
        if filters:
            if filters.get('date_from'):
                query['entry_date__gte'] = filters['date_from']
            if filters.get('date_to'):
                query['entry_date__lte'] = filters['date_to']
            if filters.get('is_favorite'):
                query['is_favorite'] = True
            if filters.get('tag_ids'):
                query['tag_ids__in'] = filters['tag_ids']
        
        return JournalEntryMongo.objects(**query).order_by('-entry_date')
    
    @staticmethod
    def search_entries(user, search_query):
        """
        Full-text search in MongoDB
        """
        return JournalEntryMongo.objects(
            user_id=user.id
        ).search_text(search_query).order_by('$text_score')


# ============================================================
# docker-compose.yml - Add MongoDB
# ============================================================

"""
Add to docker-compose.yml:

  mongodb:
    image: mongo:7
    volumes:
      - mongodb_data:/data/db
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=admin123
      - MONGO_INITDB_DATABASE=mindnotes
    ports:
      - "27017:27017"
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/test --quiet
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  mongodb_data:
"""